<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏</title>
</head>
<body>
    <h1>–ú–æ–∏ –∑–∞–¥–∞—á–∏</h1>
    <div id="user-info" 
         data-username="{{ request.user.username }}" 
         data-token="{{ request.user.profile.verification_token }}"
         data-chat-id="{{ request.user.profile.telegram_chat_id|default:'' }}">
        
        <h2>–ü—Ä–∏–≤—è–∑–∫–∞ Telegram</h2>
        {% if request.user.profile.telegram_chat_id %}
            <p>‚úÖ –í–∞—à Telegram –∞–∫–∫–∞—É–Ω—Ç –ø—Ä–∏–≤—è–∑–∞–Ω.</p>
        {% else %}
            <p>üîó –î–ª—è –ø—Ä–∏–≤—è–∑–∫–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –±–æ—Ç—É –∫–æ–º–∞–Ω–¥—É <code>/start {{ request.user.profile.verification_token }}</code></p>
        {% endif %}
    </div>

    <div id="tasks-list-container">
        <h2>–ù–µ–≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏</h2>
        <ul id="pending-tasks-list">
            </ul>
        
        <h2>–í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏</h2>
        <ul id="completed-tasks-list">
            </ul>
    </div>

    <script>
        const userInfo = document.getElementById('user-info');
const pendingList = document.getElementById('pending-tasks-list');
const completedList = document.getElementById('completed-tasks-list');
const wsUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + 
              window.location.host + '/ws/tasks/';
let taskSocket = null;


// --- 1. Websocket Connection and Handlers ---

function connectWebSocket() {
    taskSocket = new WebSocket(wsUrl);

    taskSocket.onopen = function(e) {
        console.log("[open] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.");
    };

    taskSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        if (data.type === 'task_update') {
            handleTaskUpdate(data.data);
        }
    };

    taskSocket.onclose = function(e) {
        console.log("[close] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã...", e.code);
        taskSocket = null;
        setTimeout(connectWebSocket, 3000);
    };

    taskSocket.onerror = function(e) {
        console.error("[error]", e);
        taskSocket.close();
    };
}


// --- 2. DOM Manipulation ---

function createTaskElement(task) {
    const li = document.createElement('li');
    li.id = `task-${task.id}`;
    li.innerHTML = `
        <strong>${task.title}</strong> 
        (–°—Ä–æ–∫: ${task.due_date ? new Date(task.due_date).toLocaleString() : '–ù/–£'}, 
        –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${task.assigned_to.username})
        ${task.is_completed ? '' : `<button data-task-id="${task.id}" onclick="completeTask(${task.id})">‚úÖ –í—ã–ø–æ–ª–Ω–∏—Ç—å</button>`}
    `;
    return li;
}

function handleTaskUpdate(task) {
    const existingElement = document.getElementById(`task-${task.id}`);
    
    if (existingElement) {
        existingElement.remove(); // –£–¥–∞–ª—è–µ–º –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Å–ø–∏—Å–∫–∞
    }
    
    const newElement = createTaskElement(task);
    
    if (task.is_completed) {
        completedList.prepend(newElement);
    } else {
        pendingList.prepend(newElement);
    }
    console.log(`Task ${task.id} updated/moved.`);
}


// --- 3. API Interaction (Fetch) ---

async function fetchTasks() {
    try {
        // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ Django Session Auth —Ä–∞–±–æ—Ç–∞–µ—Ç
        const response = await fetch('/api/v1/tasks/'); 
        const tasks = await response.json();
        
        pendingList.innerHTML = '';
        completedList.innerHTML = '';
        
        tasks.forEach(task => handleTaskUpdate(task)); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è
        
    } catch (error) {
        console.error('Error fetching tasks:', error);
    }
}

async function completeTask(taskId) {
    try {
        const response = await fetch(`/api/v1/tasks/${taskId}/complete/`, {
            method: 'POST',
            // Django requires CSRF token for POST requests
            headers: {
                'X-CSRFToken': getCookie('csrftoken'), 
                'Content-Type': 'application/json'
            },
        });
        
        if (!response.ok) throw new Error('Failed to complete task');
        
        // WS —Å–∞–º –æ–±–Ω–æ–≤–∏—Ç UI, –Ω–æ –µ—Å–ª–∏ –Ω–µ—Ç (–æ—à–∏–±–∫–∞ —Å–µ—Ç–∏), —Ç–æ –º–æ–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –≤—Ä—É—á–Ω—É—é
        // const updatedTask = await response.json();
        // handleTaskUpdate(updatedTask);
        
    } catch (error) {
        console.error(`Error completing task ${taskId}:`, error);
    }
}

// Helper to get CSRF token for Django
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            let cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// --- 4. Initialization ---

document.addEventListener('DOMContentLoaded', () => {
    fetchTasks();
    connectWebSocket();
});
    </script>
</body>
</html>